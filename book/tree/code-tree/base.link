
head 3, text <The {code(<load>)}>

flow <The load is for importing cards into this existing card.>

code link, text <
  load ./x
    find x
      save x-y
>

turn x # not x

load @foo/bar
  find x, save y

head 3, text <The form>

form x
  take a, like a

form x
  take a # two choices
    like a
    like b

- Basic form defininig properties.
- Alias form for a complex form (like).
- Enum form

form x
  take a, like list, head site, like x

form x
  take a, like w

form y
  like list
    bind seat, like z

form x
  take a, like y

form x
  head a
  take b, loan a

take x, list y
take x, fold y, term x
take x, like text
  void take
  lock free

The types of questions you can ask:

- What is the exact form of this object?
- What is the exact wear of this object?
- What can this object be cast into?
- What does this object look like?

To check what an object looks like, you need to inspect the object and compare it against other objects.

head 3, text <The like>

like task
  head x
  take y
  free z
like list
  like x
like mesh
  like text
  like x
like mesh
  term [name]
  like x
mesh x, term [name]
list x
like sink # or/union
  like x
  like y
  like z
like link # and/intersection
  like x
  like y
  like z
like weed # maybe
  like x
like weed
  bind seat
    like x

head 3, text <The task>

task p
  head x, like like
    time m
  take a, like x
    time m
  take b, like x
    time m
  free y, like x

  call w
    head x, like t
    loan x
    loan y
    save z

  hold is-true
    [..bindings]

  show loan a

  foul <error>
  halt <wont get here>

form x
  task p, base p

Start the program with:

hook boot

task x
  make a
    head x, like y
    bind m, size 10
    save y
  back y

head 3, text <The link>

code link, text <
  loan a/b[c/d][e]/f[g[h[i/j]]]
>

code link, text <
  loan a
    site b
    nest c
      site d
    nest e
    site f
    nest g
      nest h
        nest i
          site j
>

loan a/~b

loan a
  site b, cite take

loan a?[b]/c

loan a, void take
  nest b
  site c

loan *a[*b]/c

loan a, dive take
  nest b, dive take
  site c

loan *a

loan a, dive take

move x

read x

head 3, text <The call>

call x

call self/m

call x
  bind a, size 10

call x
  bind a, size 10
  hook w
    take x
    take y

call x
  save a
  save b

call x
  find x # skip
  find y, save z

call w
  head x, like t
  loan x
  loan y

head 3, text <The walk>

walk list, loan x
  fork p
  hook take
    hold x
    hold y
  hook free
    hold x
    hold y
  hook tick
    take a, name w
    call x
    bust p

walk band
  size 3
  size 10
  hook tick
    take i

walk band
  size 3
  size 10
  take i

walk size, size 100
  take i
  show i

walk test, fork name
  test is-less
  show <step>

save *a/b, size 10

head 3, text <The stem>

The if/else statement:

stem roll
  stem test
    test is-equal
      size 10
      size 20
    hook take
      show <weird>
  stem test
    test is-equal
      size 10
      size 10
    hook take
      show <normal>
  hook free
    show <nope>

The and statement:

stem link
  test is-equal
    size 20
    size 20
  test is-equal
    size 10
    size 10
  hook take
    show <made it>
  hook free
    show <didn't make it>

The or statement:

stem sink
  test is-equal
    size 10
    size 20
  test is-equal
    size 10
    size 30
  test is-equal
    size 10
    size 10
  hook take
    show <made it>
  hook free
    show <didn't make it>

That is short for this:

stem sink
  hook test
    test is-equal
      size 10
      size 20
  hook test
    test is-equal
      size 10
      size 30
  hook test
    test is-equal
      size 10
      size 10
  hook take
    show <made it>
  hook free
    show <didn't make it>

The if/else statement:

stem roll
  hook test
    test is-equal
      loan status
      term success
  hook take
    show <success>
  hook test
    test is-equal
      loan status
      term failure
  hook take
    show <failure>

The case statement:

stem case
  loan status
  case term success
    show <saved file>
  case term failure
    show <didn't save file>
  hook free

The case statement for checking the types:

stem case
  loan status/@/form
  case like foo
  case like bar

head 3, text <The risk>

The risk statement, like unsafe in rust.

risk take
  call save-file
    wait take
    text <path.txt>
    text <content >
      loan z
      cord < more content>
    save status

head 3, text <The fork>

Creating a new scope.

fork foo
  save a, size 10

head 3, text <The mask>

A mask is like a rust trait or an interface. You can do multiple inheritance of masks, but you just can't override methods calling super like in object-oriented languages. You can have a custom implementation, but that's it.

mask r
mask s

mask w
  base r
  base s
  head a
  head b
  take x
  take y
  task p
  task q

head 3, text <The host>

Hosts are basically namespaces or bindings to values. Basically they are defining arbitrary objects.

host foo
  host bar
    task x
    form y
    host z
      host a, text <Foo>
        note <Foo>
    slot x
    stem test
      test is-equal
        loan a
        loan b
      tool x
        host w
        host r

head 3, text <The text>

text <foo>

text <hello {world}>

text ./external

text ./external
  bind x, size 10
  bind y, loan foo

text loaded

head 3, text <The fuse>

The fuse should work in every context.

fuse ./path

fuse ./path
  bind x, size 10

fuse x

load ./x
  find tree foo

form x
  fuse foo
    size 10
    size 20

tree foo
  take x
  take y

  hook bind
    take a, base loan x
    take b, base loan y

head 3, text <The clue>

The clue is to switch parsing contexts, like you are in a separate file. Like you have CSS inside of HTML.

clue book
  head <Title>

head 3, text <The slot>

The slot term is for specifying a place where you can return to to inject content in.

form x
  slot sx
  walk list
    make list
      term a
      term b
      term c
    hook tick
      take term
      beam sx
        take loan term

head 3, text <The feed>

cull user-location
  feed user
    feed email
    feed name
    feed location
      feed lat
      feed lng
  hold match
    bind base, link user/email
    bind head, loan grammar
  sort user/email, rank head
  lead 100
  base 10 # offset

macro_rules! ast_enum_of_structs {
    (
        $(#[$enum_attr:meta])*
        pub enum $name:ident {
            $(
                $(#[$variant_attr:meta])*
                pub $variant:ident $( ($member:ident $($rest:tt)*) )*,
            )*
        }

        $($remaining:tt)*
    ) => (
        ast_enum! {
            $(#[$enum_attr])*
            pub enum $name {
                $(
                    $(#[$variant_attr])*
                    $variant $( ($member) )*,
                )*
            }
        }

        $(
            maybe_ast_struct! {
                $(#[$variant_attr])*
                $(
                    pub struct $member $($rest)*
                )*
            }

            $(
                impl From<$member> for $name {
                    fn from(e: $member) -> $name {
                        $name::$variant(e)
                    }
                }
            )*
        )*

        #[cfg(feature = "printing")]
        generate_to_tokens! {
            $($remaining)*
            ()
            tokens
            $name { $($variant $( [$($rest)*] )*,)* }
        }
    )
}

Here is the macro defined with tree and used with fuse.

tree ast-enum-of-structs
  take enum-attribute, list attribute
  take name, like term
  take variant-entry
    like list
      like form
        take variant-attribute, list attribute
        take variant, like term
        take member-entry
          like list
            like form
              take member, like term
              take rest, list tree
  hook bind
    form loan name
      slot form
      walk list
        loan enum-attribute
        link attribute
        hook tick
          beam form
            mark loan attribute
            walk list
              loan variant-entry
              link entry
              hook tick
                beam form
                  case loan entry/variant
                    mark loan entry/variant-attribute
                    slot case
                    walk list
                      loan entry/member-entry
                      link entry
                      hook tick
                        beam case
                          like entry/member
                            slot like
                            walk list
                              loan entry/rest
                              like rest
                              hook tick
                                beam like
                                  fuse loan rest

Mark things which need work so it can crash if you don't handle it.

calm variable is a constant, which the compiler can treat specially.

**self

loan size, dive take, size 2

stem case
  loan item
  case like item-use
    show loan item/a

match item {
  syn::Item::Use(x) => {
    println!(x)

pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {
  if let Ok(ref t) = self {
    f(t);
  }

  self
}

task inspect
  head f
    like fn-once
      like t
        cite take
  take self, like self
  take f, like f
  free self, like self

  stem case
    loan self
    case like ok
      call loan f
        loan self/0

The walk mask is an iterator trait. It allows you to define the walk method on a collection.

The twin mask is the copy trait or clone trait. The clone trait is the boom-twin mask.

The fall mask is the default trait.

The text mask is for formatting for text display.

suit iterator
  fill a
  fill b
  fill c

  fold a
  fold b

  wear form-iterator
    fold c
    task next

suit iterator
  head a
  head b
  head c

  hook bind
    head a
    head b

    wear form-iterator
      head c
      task next

That suits the iterator with the form-iterator mask.

mask form-iterator
  task next

seed x # derive the stuff for the thing.

cool x, enable a feature for the deck

boot [request]
  head
  take
  rank [protocol]
  hint [header1]
  hint [header2]
  mate [user]
  code [password]
  host [domain]
  dock [port]
  line [path]
  find [search-param]
  deed [method]
  seed [body]
  loot [response]

loot [response]
  code 200
  hint
  seed
  free

head <The {code(<deck>)}>
  flow <The {code(<deck>)} is where it all begins.>

deck @drumwork/base
  head <Link Script Compiler>
  term <Link Script>
  term <Computation>
  term <Philosophy>
  term <Information>
  term <Platform>
  term <White Label>
  mate <Lance Pollard>, site <lp@elk.fm>
  site <repository>
  mark <0.0.1>
  dock task # the task loader
  dock code # the library loader
  read book # also a default
  code <Apache 2.0>

lace form
  bind form

lace text, text <text>
lace text, code #x123

walk

test

seek

call

hold

The head for the mill is just like a normal input value.

mill boolean
  head text

The call for a mill is just like a normal call.

mill boolean
  call parse-string-to-boolean
    bind text, <123>
    turn base

The turn for a call is for returning a value, turning around and giving the value.

mill string
  turn seed, link symbol

The seed turn is the standard return variable name.

The save is for defining a variable.

mill string
  save symbol

The mill-test is a checker which if conditionally true will resolve the branched milles.

mill x
  test test-mesh
    bind base, link text
    bind head, text <->
    hook mesh
      save minus, link true

Nested milles work as expected, they all possibly get evaluated as they get found.

mill x
  mill exponent
    mill sign
    mill integer

The make is just like a normal make, building an object.

mill object
  make object
    save object

The line zone is for concatenating an array.

mill array
  mill value, form value
    line item

The mill-form is for referencing other milles.

mill value
  mill string, form string
    turn seed
The mine-form references a separate form or "class" to replace it with.

The mine-list is a chain, which iterates over values in the text.

mine list
  bind base, mark 2
  bind head, mark 4
  mine text, text <x>

The mine-miss is like a sieve, allowing optional match of content.

mine miss
  mine text, text <x>

The mine-head is like matching the first match.

mine head
  mine text, text <x>
  mine text, text <y>
  mine text, text <z>

The call is a type of zone for the mine. It calls a function for the input.

The mine-text is for matching exact text, which can be code for symbols, cord for strings, and mark for numbers.

mine text, text <x>
mine text, mark 123
mine text, code #h123
mine text, link x

The mine-test is for checking if a value fits certain constraints, and if so, it executes the parser for that branch.

mine test, test test-is-equal
  bind base, link x
  bind head, link y
  mine ...

The mine-band is for clipping a range of values.

The mine-mark is for specifying a specific number of things.

Write each one in isolation for testing, then combine them in the end.

Then mine-slab is a block.

view glyph-g
  curl glyph-g-start
    move x, y
    line x, y
    bend cx, cy, x, y
      turn take
    bend cx, cy, x, y
      turn take
    turn 2
    arch rx, ry, angle, flag1, flag2, x, y
      slot free (absolute position)
    halt lead

view verse
  take trace

  host is-title-visible
  host is-entering-title
  host is-leaving-title

  tune x
    move fade-in
      hook update
        base value
        save x, link value
  tune y
    move fade-out

  hook mount-start
    save is-entering-title, link on
    save is-title-visible, link on
  hook leave-start
    save is-leaving-title, link on
  hook leave
    save is-title-visible, link off

  slab title
    test is-entering-title
      tune animate-opacity-and-width
        hook end
          save is-entering-title, link off
    test is-leaving-title
      tune leave
    test is-title-visible

bind form
  head a
  head b
  head c

  suit iterator
    head a
    head b

    wear form-iterator
      head c
      task next

suit iterator
  head a
  head b

  wear form-iterator
    head c
    task next

# impl<T: Clone, A: Allocator> Vec<T, A>

suit form
  head item-type, base clone
  head allocator, base allocator

  coat list
    head item-type
    head allocator

    task resize
      take self
      take size
      take fill

# impl<T: PartialEq, A: Allocator> Vec<T, A> {


# impl<T: Clone, A: Allocator> Vec<T, A>

suit form
  head item, bind base, like clone
  head allocator, bind base, like allocator

  coat list
    head item
    head allocator

    task resize
      take self
      take size
      take fill

# impl<T: PartialEq, A: Allocator> Vec<T, A> {

suit form
  head item, bind base, like equality
  head allocator, bind base, like allocator

  coat list
    head item
    head allocator

    task deduplicate
      take self, lock false

# impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A>

suit form
  head item, bind base, like clone
  head allocator
    bind base
      like and
        like allocator
        like clone

  coat list
    head item
    head allocator

    wear clone
      task clone
        take self, loan true

# impl<T: Hash, A: Allocator> Hash for Vec<T, A>

suit form
  head item, bind base, like hash
  head allocator, bind base, like allocator

  coat list
    head item
    head allocator

    wear hash
      task hash
        take self, loan true

# impl<T, I: SliceIndex<[T]>, A: Allocator> Index<I> for Vec<T, A>
#    type Output = I::Output;

suit form
  head item, bind base, like hash
  head i, bind base, like slice-read, like line, like item
  head allocator, bind base, like allocator

  coat list
    head item
    head allocator

    wear read
      head i
      take output, i/output

      task read
        take self
        take read, like i
        free self/output, loan true

suit form
  head item, bind base, like hash
  head i, bind base, like slice-read, like line, like item
  head allocator, bind base, like allocator

  coat list
    head item
    head allocator

    wear read-flex
      head i
      take output, i/output

      task read
        take self, flex true
          loan true
        take read, like i
        free self/output, flex true
          loan true

# impl<T, A: Allocator> IntoIterator for Vec<T, A> {
#     type Item = T;
#     type IntoIter = IntoIter<T, A>;

suit form
  head item
  head allocator, bind base, like allocator

  coat list
    head item
    head allocator

    wear becoming-iteratable
      head i
      take item, like item
      take iterator
        like becoming-iterator
          like item
          like allocator

use firm for class tasks and bases
mutable is flex
comb is decimal

base name
  firm true

use loan x to say that it is a borrowed reference

The cite true is metadata saying it is a loan type

The move is the specific one, the loan occurs by default.

You can call it `read` then, and then `read x, move true`, or even `move x`.

A lack is a none type.

PartialOrder and TotalOrder

call bitwise-or
  call multiply
    call math/abs
      call math/sin
        call add
          loan i
          mark 1
    mark 4294967296
  mark 0

The chaining operator.

call @bitwise-or
  call @multiply
    call @abs
      call @sin
        call i/add, mark 1
    mark 4294967296
  mark 0

have i
  call @add, mark 1
  call @sin
  call @multiply, mark 4294967296
  call @bitwise-or, mark 0

call i/add, mark 1
  call @sin
  call @multiply, mark 4294967296
  call @bitwise-or, mark 0

a[z.w(1).x] = true

call a/save
  call z/w, mark 1
    link x
  read true

call a/read, read z

a.z = true

save a/z, read true

a.z(1).x = true

call a/z, mark 1
  link save, term x

save
  call a/z, mark 1
    link x

call a/z, mark 1
  save x, read true

t[1]

call t/read, mark 1

x = 10

call x/save, mark 10
save x, mark 10

t[1].foo.bar = value

save t[1]/foo/bar, read value

call t/read, mark 1
  link foo/bar/save, read value

t[1][foo] = 10

call t/read, mark 1
  link save, read foo
    mark 10

t[1 + c][f | d] = 10

call t/read, call 1/add, read c
  link save
    call f/bitwise-or, read d
    mark 10

save x, call t/read, call 1/add, read c
call x/save
  call f/bitwise-or, read d
  mark 10

save t[call 1/add, read c][call f/or, read d], mark 10

save x, call 1/add, read c
save y, call f/or, read d
save t[x][y], mark 10

t[0].x(a, b(c, 1)).y = 20

call t[0]/x
  read a
  call b
    read c
    mark 1
  link y/save, mark 20

save p
  call t[0]/x
    read a
    call b
      read c
      mark 1
save p/y, mark 20
