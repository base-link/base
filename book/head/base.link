
head <The Head>

This language is meant to build other languages on, like an intermediate representation for languages, which you can also write directly.

There is a `want` type, which is the result of side-effectful computations. You then check the want.value to get the result, which could be an exception or a value, or a waiting thing, or something else. Or a lead. A lead is the result you get back which you can unpack.

This is an experiment to see if you can write a simple language that is powerful enough to capture all your needs in programming. Then the simple base can be used to build more concise layers on top, but will be backed by this readable intermediate language.

This is a "data modeling language". It is used primarily to model your data in an easy to read way. It can also be used to write programs, but it turns out that writing programs the same way you write your data models is a tad bit verbose, and could use some syntax niceties like binary / arithmetic operators or simpler function calling interfaces without the boilerplate. However, having this standard intermediate representation, which you can also use for modeling all kinds of stuff, is a useful step for cleaning up the software we write and standardizing it as much as possible.

Another goal is to write algorithms and models in a simple and standard, from-the-textbook sort of way, not polluted by this or that compiler metadata or things of that nature.

- Easy to write, like simple note taking abilities.
- Easy to extend into custom DSLs.

So you have the lead and the loan (borrow) or the host (owner). These govern side effects and mutable changes to state.

The type inference flows through scope changes, so when you go through an if-statement, you extend the current scope into a new scope in the tree/branch. This tells you the typinig environment and what your type might be at that time.

The slot is the pointer (index or address, and value or object).

So the I/O functions return leads. You can halt on any specific point.

It can also turn fall or throw an error.

turn halt is throwing an error
turn back is returning value
seed back is like yielding to a function

A mesh is a base object. A blob is a generic value.

The fork line/tree is the lexical scope.
The call line is the current trace of calls.

The fork line is as follows:

- base
- file
- task/form
- stem (branch in logic)

The lead is the result of side effect computation.

task x
  wait take (is async)

  fork name
    Creates a new scope.

zone x
  view button

A zone is a component.

task x
  link y
  link z

form x
  link y
  link z

Convert the docs to markdown.

option type
maybe type
any type

https://papl.cs.brown.edu/2015/Type_Inference.html
https://www.infoq.com/articles/java-local-variable-type-inference/

Types to consider:

- And (link)
- Or (sink)
- Either (toss)
- Decidable (side)
- Maybe/Option (weed)
  - Some (boom)
  - None (bust)
- Empty (void)
- Any (cool)
- Boolean (code)
- Never (miss)
- Not (turn)
- Goal (want)
- IO (lead)
- Result (bill)
- Unknown (mask)

The definition of types is the public Mesh. But the compiler may deal with them in special ways under the hood.

task
  take name, like name
  free name

- And (twin)
- Or (sink)
- Decidable (side)
- Maybe/Option (weed)
  - Some (boom)
  - None (bust)
- Empty (void)
- Any (cool)
- Boolean (code)
- Never (miss)
- Not (turn)
- Goal (want)
- IO (lead)
- Result (bill)
- Unknown (mask)

like and
  like x
  like y
twin x
  twin y

like maybe
  like x

weed x

like not
  like x

turn x

like or
  like x
  like y

sink x
  sink y
